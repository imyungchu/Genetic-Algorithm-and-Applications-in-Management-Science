# -*- coding: utf-8 -*-
"""final_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MZf6gbNiMEgDDF_TyoVVRzKvVgTMyJRm
"""

# 匯入資料
from google.colab import drive

drive.mount("/content/gdrive", force_remount=True)

import os 

os.listdir()
os.chdir("gdrive/My Drive/GA_final")

import pandas as pd
os.listdir()
data = pd.read_csv("GA_final.txt",encoding="utf8")

data

data2 = pd.pivot_table(data,values="收盤價(元)",index="年月日",columns="證券代碼")
data2

data2.index = pd.to_datetime(data2.index,format="%Y%m%d")
data2

from datetime import datetime 
import numpy as np
start_time = datetime(2017,12,29)
end_time = datetime(2019,12,31)
GA_data = data2.loc[start_time:end_time,:]
from google.colab import files
GA_data_plt = GA_data
drop_col = []
for i in GA_data.columns:
  if ord(i[0])>65:
    drop_col.append(i)
GA_data = GA_data.drop(drop_col,axis= 1).dropna(axis= 1)
final_return = (GA_data.iloc[-1,:]-GA_data.iloc[1,:])/GA_data.iloc[1,:]
initial_cost = GA_data.iloc[1,:]
GA_data = ((GA_data-GA_data.shift(1))/GA_data.shift(1)).iloc[1:,:]
GA_cov = GA_data.cov()
max_std = GA_data.std().max()
min_std = GA_data.std().min()
print(GA_data)

# 找 x 使得最大化 f(x) = 1024 - x^2
# x 用 6 個 binary bit 編碼

import numpy as np
import itertools
# import math
# ==== 參數設定(與演算法相關) ====
parameter_weight = {"return":2,
           "cost":1.5,
           "std":2}
NUM_ITERATION = 200			# 世代數(迴圈數)

NUM_CHROME = 100				# 染色體個數 (一定要偶數)
NUM_BIT = 20					# 染色體長度

Pc = 0.75    					# 交配率 (代表共執行Pc*NUM_CHROME/2次交配)
Pm = 0.1   					# 突變率 (代表共要執行Pm*NUM_CHROME*NUM_BIT次突變)

NUM_PARENT = NUM_CHROME                         # 父母的個數
NUM_CROSSOVER = int(Pc * NUM_CHROME / 2)        # 交配的次數
NUM_CROSSOVER_2 = NUM_CROSSOVER*2               # 上數的兩倍
NUM_MUTATION = int(Pm * NUM_CHROME * NUM_BIT)   # 突變的次數

PENALTY_COST = 1000

# np.random.seed(0)          # 若要每次跑得都不一樣的結果，就把這行註解掉

# ==== 基因演算法會用到的函式 ====
def initPop():             # 初始化群體
  return np.random.randint(len(GA_cov), size=(NUM_CHROME,NUM_BIT)) # 產生 NUM_CHROME 個二元編碼

def fitFunc(x):            # 適應度函數
  total_var = 0
  total_return = 0
  total_cost = initial_cost.iloc[x].sum()
  total_weight = initial_cost/total_cost #?
  for i in x:
    total_var += total_weight.iloc[i]**2 * GA_cov.iloc[i,i] #?
    total_return += total_weight.iloc[i] * final_return.iloc[i] #?
  for i in itertools.combinations(x,2):
    total_var += 2*total_weight.iloc[i[0]]*total_weight.iloc[i[1]]*GA_cov.iloc[i[0],i[1]]
  budget_deduct = 0
  if total_cost>1000:
    budget_deduct = 2*(total_cost-1000)/1000
  elif total_cost < 1000:
    budget_deduct = (1000-total_cost)/1000
  std_deduct = (np.sqrt(total_var)-min_std)/(max_std-min_std)
  count_duplicates = NUM_BIT - len(np.unique(x))
  return total_return*parameter_weight["return"]-std_deduct*parameter_weight["std"]-budget_deduct*parameter_weight["cost"] - 0.1 *count_duplicates
    
def evaluatePop(p):        # 評估群體之適應度
    return [fitFunc(p[i]) for i in range(len(p))]

def selection(p, p_fit):   # 用二元競爭式選擇法來挑父母
	a = []

	for i in range(NUM_PARENT):
		[j, k] = np.random.choice(NUM_CHROME, 2, replace=False)  # 任選兩個index
		if p_fit[j] > p_fit[k] :                      # 擇優
			a.append(p[j])
		else:
			a.append(p[k])

	return a

def crossover(p):           # 用單點交配來繁衍子代
	a = []

	for i in range(NUM_CROSSOVER) :
		c = np.random.randint(1, NUM_BIT)      		  # 隨機找出單點(不包含0)
		[j, k] = np.random.choice(NUM_PARENT, 2, replace=False)  # 任選兩個染色體
       
		a.append(np.concatenate((p[j][0: c], p[k][c: NUM_BIT]), axis=0))
		a.append(np.concatenate((p[k][0: c], p[j][c: NUM_BIT]), axis=0))

	return a

def mutation(p):	           # 突變
	for _ in range(NUM_MUTATION) :
		row = np.random.randint(NUM_CROSSOVER_2)  # 任選一個染色體
		col = np.random.randint(NUM_BIT)          # 任選一個基因
      
		p[row][col] = (p[row][col] + 1) % 2       # 對應此染色體的此基因01互換
        

def sortChrome(a, a_fit):	    # a的根據a_fit由大排到小
    a_index = range(len(a))                         # 產生 0, 1, 2, ..., |a|-1 的 list
    
    a_fit, a_index = zip(*sorted(zip(a_fit,a_index), reverse=True)) # a_index 根據 a_fit 的大小由大到小連動的排序
   
    return [a[i] for i in a_index], a_fit           # 根據 a_index 的次序來回傳 a，並把對應的 fit 回傳

def replace(p, p_fit, a, a_fit):            # 適者生存
    b = np.concatenate((p,a), axis=0)               # 把本代 p 和子代 a 合併成 b
    b_fit = p_fit + a_fit                           # 把上述兩代的 fitness 合併成 b_fit
    
    b, b_fit = sortChrome(b, b_fit)                 # b 和 b_fit 連動的排序
    
    return b[:NUM_CHROME], list(b_fit[:NUM_CHROME]) # 回傳 NUM_CHROME 個為新的一個世代


# ==== 主程式 ====

pop = initPop()             # 初始化 pop
pop_fit = evaluatePop(pop)  # 算 pop 的 fit

best_outputs = []                           # 用此變數來紀錄每一個迴圈的最佳解 (new)
best_outputs.append(np.max(pop_fit))        # 存下初始群體的最佳解 (new)

mean_outputs = []                           # 用此變數來紀錄每一個迴圈的平均解 (new)
mean_outputs.append(np.average(pop_fit))        # 存下初始群體的最佳解 (new)

for i in range(NUM_ITERATION) :
    parent = selection(pop, pop_fit)            # 挑父母
    offspring = crossover(parent)               # 交配
    mutation(offspring)                         # 突變
    offspring_fit = evaluatePop(offspring)      # 算子代的 fit
    pop, pop_fit = replace(pop, pop_fit, offspring, offspring_fit)    # 取代
    
    best_outputs.append(np.max(pop_fit))        # 存下這次的最佳解 (new)
    mean_outputs.append(np.average(pop_fit))    # 存下這次的平均解 (new)

    print('iteration %d: x = %s, y = %f'	%(i, pop[0], pop_fit[0]))
    

x = pop[0]
total_var = 0
total_return = 0
total_cost = initial_cost.iloc[x].sum()
total_weight = initial_cost/total_cost
for i in x:
  total_var += total_weight.iloc[i]**2 * GA_cov.iloc[i,i]
  total_return += total_weight.iloc[i] * final_return.iloc[i]
for i in itertools.combinations(x,2):
  total_var += 2*total_weight.iloc[i[0]]*total_weight.iloc[i[1]]*GA_cov.iloc[i[0],i[1]]
print("best return %f, best std %f, best cost %f" %(total_return,np.sqrt(total_var),total_cost))

total_return

# 畫圖 (new) oneP
import matplotlib.pyplot
matplotlib.pyplot.plot(best_outputs)
matplotlib.pyplot.plot(mean_outputs)
matplotlib.pyplot.xlabel("Iteration")
matplotlib.pyplot.ylabel("Fitness")
matplotlib.pyplot.show()

# 畫圖 (new) twoP
import matplotlib.pyplot
matplotlib.pyplot.plot(best_outputs)
matplotlib.pyplot.plot(mean_outputs)
matplotlib.pyplot.xlabel("Iteration")
matplotlib.pyplot.ylabel("Fitness")
matplotlib.pyplot.show()

# 畫圖 (new) uni
import matplotlib.pyplot
matplotlib.pyplot.plot(best_outputs)
matplotlib.pyplot.plot(mean_outputs)
matplotlib.pyplot.xlabel("Iteration")
matplotlib.pyplot.ylabel("Fitness")
matplotlib.pyplot.show()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime 
import os 
from google.colab import drive



os.listdir()
data = pd.read_csv("draw_data.csv")
print(data)#這個應該已經是報酬率了
print(GA_data)
ga_df=pd.DataFrame(data)
#ga_df.to_csv("data.csv")
#files.download("data.csv")
#print(ga_df[[0050]])
#plt.plot(GA_data.iloc[:,1:2])
#plt.plot(GA_data.iloc[:,2:3])
#print(GA_data.iloc[:,1:2])
#print(ga_df.iloc[:,1:2]+ga_df.iloc[:,2:3])

